import { z } from 'zod';
import { router, protectedProcedure } from '../trpc';
import { db } from '@/db';
import { insightsCache } from '@/db/schema';
import { eq, and } from 'drizzle-orm';

// Mock Gemini function - returns beautiful markdown with headings, emojis, and lists
async function callGeminiForInsights(files: Array<{ path: string; content: string }>, repoName: string): Promise<string> {
  const fileCount = files.length;
  const totalLines = files.reduce((sum, file) => sum + file.content.split('\n').length, 0);

  const languages = new Map<string, number>();
  files.forEach(file => {
    const ext = file.path.split('.').pop()?.toLowerCase();
    if (ext) {
      const langMap: Record<string, string> = {
        'js': 'JavaScript', 'ts': 'TypeScript', 'py': 'Python', 'java': 'Java',
        'cpp': 'C++', 'cs': 'C#', 'go': 'Go', 'rs': 'Rust', 'php': 'PHP',
        'rb': 'Ruby', 'swift': 'Swift', 'kt': 'Kotlin', 'scala': 'Scala',
        'r': 'R', 'sh': 'Shell', 'html': 'HTML', 'css': 'CSS', 'vue': 'Vue',
        'jsx': 'React', 'tsx': 'React', 'svelte': 'Svelte'
      };
      const lang = langMap[ext];
      if (lang) languages.set(lang, (languages.get(lang) || 0) + 1);
    }
  });

  const languageList = Array.from(languages.entries())
    .sort((a, b) => b[1] - a[1])
    .map(([lang, count]) => `- **${lang}**: ${count} file${count > 1 ? 's' : ''}`)
    .join('\n');

  return `# 📝 Repository Analysis: ${repoName}

## 📊 Overview

**Files:** ${fileCount}  
**Lines of code:** ${totalLines}

## 🗣️ Language Breakdown

${languageList || '- _No major languages detected_'}

## 🏗️ Architecture

**Type:** ${fileCount > 50 ? 'Monorepo' : 'Standard Repository'}  
**Complexity:** ${totalLines > 10000 ? 'High' : totalLines > 5000 ? 'Medium' : 'Low'}

## 🔍 Key Patterns Detected

${files.some(f => f.path.includes('test') || f.path.includes('spec')) ? '- **🧪 Testing:** Test files detected' : '- **🧪 Testing:** No test files found'}

${files.some(f => f.path.includes('package.json') || f.path.includes('requirements.txt')) ? '- **📦 Dependencies:** Package management files present' : '- **📦 Dependencies:** No package files detected'}

## ✅ Strengths

- Well-organized file structure
- Consistent naming conventions
- Appropriate file organization

## ⚠️ Areas for Improvement

1. Add more documentation
2. Implement automated testing if not present
3. Review dependency management

## 🚀 Recommendations

- **Documentation:** Add a comprehensive \`README.md\`
- **Testing:** Implement unit and integration tests
- **CI/CD:** Set up automated build and deployment pipelines
- **Code Quality:** Add linting and formatting tools

## 🛡️ Security Considerations

- Review third-party dependencies for vulnerabilities
- Implement proper authentication and authorization
- Consider adding security scanning to CI/CD pipeline

---

*This analysis was generated by AI and should be reviewed by a human developer.*`;
}

export const insightsRouter = router({
  generateInsights: protectedProcedure
    .input(z.object({
      user: z.string(),
      repo: z.string(),
      ref: z.string().optional().default('main'),
      files: z.array(z.object({
        path: z.string(),
        content: z.string(),
        size: z.number().optional(),
      })),
    }))
    .mutation(async ({ input }) => {
      const { repo, files } = input;
      
      try {
        // Generate insights using Gemini
        const markdownInsights = await callGeminiForInsights(files, repo);
        
        return {
          insights: markdownInsights,
          cached: false,
          stale: false,
          lastUpdated: new Date(),
        };
      } catch (error) {
        console.error('Error generating insights:', error);
        throw new Error('Failed to generate repository insights');
      }
    }),

  getInsights: protectedProcedure
    .input(z.object({
      user: z.string(),
      repo: z.string(),
      ref: z.string().optional().default('main'),
    }))
    .query(async ({ input, ctx }) => {
      const { user, repo, ref } = input;
      
      // Check for cached insights
      const cached = await db
        .select()
        .from(insightsCache)
        .where(
          and(
            eq(insightsCache.userId, ctx.user.id),
            eq(insightsCache.repoOwner, user),
            eq(insightsCache.repoName, repo),
            eq(insightsCache.ref, ref)
          )
        )
        .limit(1);

      if (cached.length > 0) {
        const insight = cached[0];
        const isStale = new Date().getTime() - insight.updatedAt.getTime() > 24 * 60 * 60 * 1000; // 24 hours
        
        return {
          insights: insight.insights,
          cached: true,
          stale: isStale,
          lastUpdated: insight.updatedAt,
        };
      }

      return {
        insights: null,
        cached: false,
        stale: false,
        lastUpdated: null,
      };
    }),

  cacheInsights: protectedProcedure
    .input(z.object({
      user: z.string(),
      repo: z.string(),
      ref: z.string().optional().default('main'),
      insights: z.any(), // The full insights object
    }))
    .mutation(async ({ input, ctx }) => {
      const { user, repo, ref, insights } = input;

      // Upsert insights cache
      await db
        .insert(insightsCache)
        .values({
          userId: ctx.user.id,
          repoOwner: user,
          repoName: repo,
          ref,
          insights,
          updatedAt: new Date(),
        })
        .onConflictDoUpdate({
          target: [insightsCache.userId, insightsCache.repoOwner, insightsCache.repoName, insightsCache.ref],
          set: {
            insights,
            updatedAt: new Date(),
          },
        });

      return { success: true };
    }),

  clearCache: protectedProcedure
    .input(z.object({
      user: z.string(),
      repo: z.string(),
      ref: z.string().optional().default('main'),
    }))
    .mutation(async ({ input, ctx }) => {
      const { user, repo, ref } = input;

      await db
        .delete(insightsCache)
        .where(
          and(
            eq(insightsCache.userId, ctx.user.id),
            eq(insightsCache.repoOwner, user),
            eq(insightsCache.repoName, repo),
            eq(insightsCache.ref, ref)
          )
        );

      return { success: true };
    }),
});
